(function(root, factory) {
    if (typeof define === 'function' && define.amd) {
        define([], factory(root));
    } else if (typeof exports === 'object') {
        module.exports = factory(root);
    } else {
        root.smoothScroll = factory(root);
    }
})(typeof global !== 'undefined' ? global : this.window || this.global, function(root) {

    'use strict';

    //
    // Variables
    //

    var smoothScroll = {}; // Object for public APIs
    var supports = 'querySelector' in document && 'addEventListener' in root; // Feature test
    var settings, eventTimeout, fixedHeader, headerHeight;

    // Default settings
    var defaults = {
        selector: '[data-scroll]',
        selectorHeader: '[data-scroll-header]',
        speed: 500,
        easing: 'easeInOutCubic',
        offset: 0,
        updateURL: true,
        callback: function() {}
    };


    //
    // Methods
    //

    /**
     * Merge two or more objects. Returns a new object.
     * @private
     * @param {Boolean}  deep     If true, do a deep (or recursive) merge [optional]
     * @param {Object}   objects  The objects to merge together
     * @returns {Object}          Merged values of defaults and options
     */
    var extend = function() {

        // Variables
        var extended = {};
        var deep = false;
        var i = 0;
        var length = arguments.length;

        // Check if a deep merge
        if (Object.prototype.toString.call(arguments[0]) === '[object Boolean]') {
            deep = arguments[0];
            i++;
        }

        // Merge the object into the extended object
        var merge = function(obj) {
            for (var prop in obj) {
                if (Object.prototype.hasOwnProperty.call(obj, prop)) {
                    // If deep merge and property is an object, merge properties
                    if (deep && Object.prototype.toString.call(obj[prop]) === '[object Object]') {
                        extended[prop] = extend(true, extended[prop], obj[prop]);
                    } else {
                        extended[prop] = obj[prop];
                    }
                }
            }
        };

        // Loop through each object and conduct a merge
        for (; i < length; i++) {
            var obj = arguments[i];
            merge(obj);
        }

        return extended;

    };

    /**
     * Get the height of an element.
     * @private
     * @param  {Node} elem The element to get the height of
     * @return {Number}    The element's height in pixels
     */
    var getHeight = function(elem) {
        return Math.max(elem.scrollHeight, elem.offsetHeight, elem.clientHeight);
    };

    /**
     * Get the closest matching element up the DOM tree.
     * @private
     * @param  {Element} elem     Starting element
     * @param  {String}  selector Selector to match against (class, ID, data attribute, or tag)
     * @return {Boolean|Element}  Returns null if not match found
     */
    var getClosest = function(elem, selector) {

        // Variables
        var firstChar = selector.charAt(0);
        var supports = 'classList' in document.documentElement;
        var attribute, value;

        // If selector is a data attribute, split attribute from value
        if (firstChar === '[') {
            selector = selector.substr(1, selector.length - 2);
            attribute = selector.split('=');

            if (attribute.length > 1) {
                value = true;
                attribute[1] = attribute[1].replace(/"/g, '').replace(/'/g, '');
            }
        }

        // Get closest match
        for (; elem && elem !== document; elem = elem.parentNode) {

            // If selector is a class
            if (firstChar === '.') {
                if (supports) {
                    if (elem.classList.contains(selector.substr(1))) {
                        return elem;
                    }
                } else {
                    if (new RegExp('(^|\\s)' + selector.substr(1) + '(\\s|$)').test(elem.className)) {
                        return elem;
                    }
                }
            }

            // If selector is an ID
            if (firstChar === '#') {
                if (elem.id === selector.substr(1)) {
                    return elem;
                }
            }

            // If selector is a data attribute
            if (firstChar === '[') {
                if (elem.hasAttribute(attribute[0])) {
                    if (value) {
                        if (elem.getAttribute(attribute[0]) === attribute[1]) {
                            return elem;
                        }
                    } else {
                        return elem;
                    }
                }
            }

            // If selector is a tag
            if (elem.tagName.toLowerCase() === selector) {
                return elem;
            }

        }

        return null;

    };

    /**
     * Escape special characters for use with querySelector
     * @private
     * @param {String} id The anchor ID to escape
     * @author Mathias Bynens
     * @link https://github.com/mathiasbynens/CSS.escape
     */
    var escapeCharacters = function(id) {
        var string = String(id);
        var length = string.length;
        var index = -1;
        var codeUnit;
        var result = '';
        var firstCodeUnit = string.charCodeAt(0);
        while (++index < length) {
            codeUnit = string.charCodeAt(index);
            // Note: there’s no need to special-case astral symbols, surrogate
            // pairs, or lone surrogates.

            // If the character is NULL (U+0000), then throw an
            // `InvalidCharacterError` exception and terminate these steps.
            if (codeUnit === 0x0000) {
                throw new InvalidCharacterError(
                    'Invalid character: the input contains U+0000.'
                );
            }

            if (
                // If the character is in the range [\1-\1F] (U+0001 to U+001F) or is
                // U+007F, […]
                (codeUnit >= 0x0001 && codeUnit <= 0x001F) || codeUnit == 0x007F ||
                // If the character is the first character and is in the range [0-9]
                // (U+0030 to U+0039), […]
                (index === 0 && codeUnit >= 0x0030 && codeUnit <= 0x0039) ||
                // If the character is the second character and is in the range [0-9]
                // (U+0030 to U+0039) and the first character is a `-` (U+002D), […]
                (
                    index === 1 &&
                    codeUnit >= 0x0030 && codeUnit <= 0x0039 &&
                    firstCodeUnit === 0x002D
                )
            ) {
                // http://dev.w3.org/csswg/cssom/#escape-a-character-as-code-point
                result += '\\' + codeUnit.toString(16) + ' ';
                continue;
            }

            // If the character is not handled by one of the above rules and is
            // greater than or equal to U+0080, is `-` (U+002D) or `_` (U+005F), or
            // is in one of the ranges [0-9] (U+0030 to U+0039), [A-Z] (U+0041 to
            // U+005A), or [a-z] (U+0061 to U+007A), […]
            if (
                codeUnit >= 0x0080 ||
                codeUnit === 0x002D ||
                codeUnit === 0x005F ||
                codeUnit >= 0x0030 && codeUnit <= 0x0039 ||
                codeUnit >= 0x0041 && codeUnit <= 0x005A ||
                codeUnit >= 0x0061 && codeUnit <= 0x007A
            ) {
                // the character itself
                result += string.charAt(index);
                continue;
            }

            // Otherwise, the escaped character.
            // http://dev.w3.org/csswg/cssom/#escape-a-character
            result += '\\' + string.charAt(index);

        }
        return result;
    };

    /**
     * Calculate the easing pattern
     * @private
     * @link https://gist.github.com/gre/1650294
     * @param {String} type Easing pattern
     * @param {Number} time Time animation should take to complete
     * @returns {Number}
     */
    var easingPattern = function(type, time) {
        var pattern;
        if (type === 'easeInQuad') pattern = time * time; // accelerating from zero velocity
        if (type === 'easeOutQuad') pattern = time * (2 - time); // decelerating to zero velocity
        if (type === 'easeInOutQuad') pattern = time < 0.5 ? 2 * time * time : -1 + (4 - 2 * time) * time; // acceleration until halfway, then deceleration
        if (type === 'easeInCubic') pattern = time * time * time; // accelerating from zero velocity
        if (type === 'easeOutCubic') pattern = (--time) * time * time + 1; // decelerating to zero velocity
        if (type === 'easeInOutCubic') pattern = time < 0.5 ? 4 * time * time * time : (time - 1) * (2 * time - 2) * (2 * time - 2) + 1; // acceleration until halfway, then deceleration
        if (type === 'easeInQuart') pattern = time * time * time * time; // accelerating from zero velocity
        if (type === 'easeOutQuart') pattern = 1 - (--time) * time * time * time; // decelerating to zero velocity
        if (type === 'easeInOutQuart') pattern = time < 0.5 ? 8 * time * time * time * time : 1 - 8 * (--time) * time * time * time; // acceleration until halfway, then deceleration
        if (type === 'easeInQuint') pattern = time * time * time * time * time; // accelerating from zero velocity
        if (type === 'easeOutQuint') pattern = 1 + (--time) * time * time * time * time; // decelerating to zero velocity
        if (type === 'easeInOutQuint') pattern = time < 0.5 ? 16 * time * time * time * time * time : 1 + 16 * (--time) * time * time * time * time; // acceleration until halfway, then deceleration
        return pattern || time; // no easing, no acceleration
    };

    /**
     * Calculate how far to scroll
     * @private
     * @param {Element} anchor The anchor element to scroll to
     * @param {Number} headerHeight Height of a fixed header, if any
     * @param {Number} offset Number of pixels by which to offset scroll
     * @returns {Number}
     */
    var getEndLocation = function(anchor, headerHeight, offset) {
        var location = 0;
        if (anchor.offsetParent) {
            do {
                location += anchor.offsetTop;
                anchor = anchor.offsetParent;
            } while (anchor);
        }
        location = location - headerHeight - offset;
        return location >= 0 ? location : 0;
    };

    /**
     * Determine the document's height
     * @private
     * @returns {Number}
     */
    var getDocumentHeight = function() {
        return Math.max(
            root.document.body.scrollHeight, root.document.documentElement.scrollHeight,
            root.document.body.offsetHeight, root.document.documentElement.offsetHeight,
            root.document.body.clientHeight, root.document.documentElement.clientHeight
        );
    };

    /**
     * Convert data-options attribute into an object of key/value pairs
     * @private
     * @param {String} options Link-specific options as a data attribute string
     * @returns {Object}
     */
    var getDataOptions = function(options) {
        return !options || !(typeof JSON === 'object' && typeof JSON.parse === 'function') ? {} : JSON.parse(options);
    };

    /**
     * Update the URL
     * @private
     * @param {Element} anchor The element to scroll to
     * @param {Boolean} url Whether or not to update the URL history
     */
    var updateUrl = function(anchor, url) {
        if (root.history.pushState && (url || url === 'true')) {
            root.history.pushState(null, null, [root.location.protocol, '//', root.location.host, root.location.pathname, root.location.search, anchor].join(''));
        }
    };

    var getHeaderHeight = function(header) {
        return header === null ? 0 : (getHeight(header) + header.offsetTop);
    };

    /**
     * Start/stop the scrolling animation
     * @public
     * @param {Element} toggle The element that toggled the scroll event
     * @param {Element} anchor The element to scroll to
     * @param {Object} options
     */
    smoothScroll.animateScroll = function(toggle, anchor, options) {

        // Options and overrides
        var overrides = getDataOptions(toggle ? toggle.getAttribute('data-options') : null);
        var settings = extend(settings || defaults, options || {}, overrides); // Merge user options with defaults
        anchor = '#' + escapeCharacters(anchor.substr(1)); // Escape special characters and leading numbers

        // Selectors and variables
        var anchorElem = anchor === '#' ? root.document.documentElement : root.document.querySelector(anchor);
        var startLocation = root.pageYOffset; // Current location on the page
        if (!fixedHeader) {
            fixedHeader = root.document.querySelector(settings.selectorHeader);
        } // Get the fixed header if not already set
        if (!headerHeight) {
            headerHeight = getHeaderHeight(fixedHeader);
        } // Get the height of a fixed header if one exists and not already set
        var endLocation = getEndLocation(anchorElem, headerHeight, parseInt(settings.offset, 10)); // Scroll to location
        var animationInterval; // interval timer
        var distance = endLocation - startLocation; // distance to travel
        var documentHeight = getDocumentHeight();
        var timeLapsed = 0;
        var percentage, position;

        // Update URL
        updateUrl(anchor, settings.updateURL);

        /**
         * Stop the scroll animation when it reaches its target (or the bottom/top of page)
         * @private
         * @param {Number} position Current position on the page
         * @param {Number} endLocation Scroll to location
         * @param {Number} animationInterval How much to scroll on this loop
         */
        var stopAnimateScroll = function(position, endLocation, animationInterval) {
            var currentLocation = root.pageYOffset;
            if (position == endLocation || currentLocation == endLocation || ((root.innerHeight + currentLocation) >= documentHeight)) {
                clearInterval(animationInterval);
                anchorElem.focus();
                settings.callback(toggle, anchor); // Run callbacks after animation complete
            }
        };

        /**
         * Loop scrolling animation
         * @private
         */
        var loopAnimateScroll = function() {
            timeLapsed += 16;
            percentage = (timeLapsed / parseInt(settings.speed, 10));
            percentage = (percentage > 1) ? 1 : percentage;
            position = startLocation + (distance * easingPattern(settings.easing, percentage));
            root.scrollTo(0, Math.floor(position));
            stopAnimateScroll(position, endLocation, animationInterval);
        };

        /**
         * Set interval timer
         * @private
         */
        var startAnimateScroll = function() {
            animationInterval = setInterval(loopAnimateScroll, 16);
        };

        /**
         * Reset position to fix weird iOS bug
         * @link https://github.com/cferdinandi/smooth-scroll/issues/45
         */
        if (root.pageYOffset === 0) {
            root.scrollTo(0, 0);
        }

        // Start scrolling animation
        startAnimateScroll();

    };

    /**
     * If smooth scroll element clicked, animate scroll
     * @private
     */
    var eventHandler = function(event) {
        var toggle = getClosest(event.target, settings.selector);
        if (toggle && toggle.tagName.toLowerCase() === 'a') {
            event.preventDefault(); // Prevent default click event
            smoothScroll.animateScroll(toggle, toggle.hash, settings); // Animate scroll
        }
    };

    /**
     * On window scroll and resize, only run events at a rate of 15fps for better performance
     * @private
     * @param  {Function} eventTimeout Timeout function
     * @param  {Object} settings
     */
    var eventThrottler = function(event) {
        if (!eventTimeout) {
            eventTimeout = setTimeout(function() {
                eventTimeout = null; // Reset timeout
                headerHeight = getHeaderHeight(fixedHeader); // Get the height of a fixed header if one exists
            }, 66);
        }
    };

    /**
     * Destroy the current initialization.
     * @public
     */
    smoothScroll.destroy = function() {

        // If plugin isn't already initialized, stop
        if (!settings) return;

        // Remove event listeners
        root.document.removeEventListener('click', eventHandler, false);
        root.removeEventListener('resize', eventThrottler, false);

        // Reset varaibles
        settings = null;
        eventTimeout = null;
        fixedHeader = null;
        headerHeight = null;
    };

    /**
     * Initialize Smooth Scroll
     * @public
     * @param {Object} options User settings
     */
    smoothScroll.init = function(options) {

        // feature test
        if (!supports) return;

        // Destroy any existing initializations
        smoothScroll.destroy();

        // Selectors and variables
        settings = extend(defaults, options || {}); // Merge user options with defaults
        fixedHeader = root.document.querySelector(settings.selectorHeader); // Get the fixed header
        headerHeight = getHeaderHeight(fixedHeader);

        // When a toggle is clicked, run the click handler
        root.document.addEventListener('click', eventHandler, false);
        if (fixedHeader) {
            root.addEventListener('resize', eventThrottler, false);
        }

    };


    //
    // Public APIs
    //

    return smoothScroll;

});

//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiIiwic291cmNlcyI6WyJzbW9vdGgtc2Nyb2xsLm1pbi5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIoZnVuY3Rpb24ocm9vdCwgZmFjdG9yeSkge1xuICAgIGlmICh0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQpIHtcbiAgICAgICAgZGVmaW5lKFtdLCBmYWN0b3J5KHJvb3QpKTtcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiBleHBvcnRzID09PSAnb2JqZWN0Jykge1xuICAgICAgICBtb2R1bGUuZXhwb3J0cyA9IGZhY3Rvcnkocm9vdCk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgcm9vdC5zbW9vdGhTY3JvbGwgPSBmYWN0b3J5KHJvb3QpO1xuICAgIH1cbn0pKHR5cGVvZiBnbG9iYWwgIT09ICd1bmRlZmluZWQnID8gZ2xvYmFsIDogdGhpcy53aW5kb3cgfHwgdGhpcy5nbG9iYWwsIGZ1bmN0aW9uKHJvb3QpIHtcblxuICAgICd1c2Ugc3RyaWN0JztcblxuICAgIC8vXG4gICAgLy8gVmFyaWFibGVzXG4gICAgLy9cblxuICAgIHZhciBzbW9vdGhTY3JvbGwgPSB7fTsgLy8gT2JqZWN0IGZvciBwdWJsaWMgQVBJc1xuICAgIHZhciBzdXBwb3J0cyA9ICdxdWVyeVNlbGVjdG9yJyBpbiBkb2N1bWVudCAmJiAnYWRkRXZlbnRMaXN0ZW5lcicgaW4gcm9vdDsgLy8gRmVhdHVyZSB0ZXN0XG4gICAgdmFyIHNldHRpbmdzLCBldmVudFRpbWVvdXQsIGZpeGVkSGVhZGVyLCBoZWFkZXJIZWlnaHQ7XG5cbiAgICAvLyBEZWZhdWx0IHNldHRpbmdzXG4gICAgdmFyIGRlZmF1bHRzID0ge1xuICAgICAgICBzZWxlY3RvcjogJ1tkYXRhLXNjcm9sbF0nLFxuICAgICAgICBzZWxlY3RvckhlYWRlcjogJ1tkYXRhLXNjcm9sbC1oZWFkZXJdJyxcbiAgICAgICAgc3BlZWQ6IDUwMCxcbiAgICAgICAgZWFzaW5nOiAnZWFzZUluT3V0Q3ViaWMnLFxuICAgICAgICBvZmZzZXQ6IDAsXG4gICAgICAgIHVwZGF0ZVVSTDogdHJ1ZSxcbiAgICAgICAgY2FsbGJhY2s6IGZ1bmN0aW9uKCkge31cbiAgICB9O1xuXG5cbiAgICAvL1xuICAgIC8vIE1ldGhvZHNcbiAgICAvL1xuXG4gICAgLyoqXG4gICAgICogTWVyZ2UgdHdvIG9yIG1vcmUgb2JqZWN0cy4gUmV0dXJucyBhIG5ldyBvYmplY3QuXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59ICBkZWVwICAgICBJZiB0cnVlLCBkbyBhIGRlZXAgKG9yIHJlY3Vyc2l2ZSkgbWVyZ2UgW29wdGlvbmFsXVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSAgIG9iamVjdHMgIFRoZSBvYmplY3RzIHRvIG1lcmdlIHRvZ2V0aGVyXG4gICAgICogQHJldHVybnMge09iamVjdH0gICAgICAgICAgTWVyZ2VkIHZhbHVlcyBvZiBkZWZhdWx0cyBhbmQgb3B0aW9uc1xuICAgICAqL1xuICAgIHZhciBleHRlbmQgPSBmdW5jdGlvbigpIHtcblxuICAgICAgICAvLyBWYXJpYWJsZXNcbiAgICAgICAgdmFyIGV4dGVuZGVkID0ge307XG4gICAgICAgIHZhciBkZWVwID0gZmFsc2U7XG4gICAgICAgIHZhciBpID0gMDtcbiAgICAgICAgdmFyIGxlbmd0aCA9IGFyZ3VtZW50cy5sZW5ndGg7XG5cbiAgICAgICAgLy8gQ2hlY2sgaWYgYSBkZWVwIG1lcmdlXG4gICAgICAgIGlmIChPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoYXJndW1lbnRzWzBdKSA9PT0gJ1tvYmplY3QgQm9vbGVhbl0nKSB7XG4gICAgICAgICAgICBkZWVwID0gYXJndW1lbnRzWzBdO1xuICAgICAgICAgICAgaSsrO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gTWVyZ2UgdGhlIG9iamVjdCBpbnRvIHRoZSBleHRlbmRlZCBvYmplY3RcbiAgICAgICAgdmFyIG1lcmdlID0gZnVuY3Rpb24ob2JqKSB7XG4gICAgICAgICAgICBmb3IgKHZhciBwcm9wIGluIG9iaikge1xuICAgICAgICAgICAgICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqLCBwcm9wKSkge1xuICAgICAgICAgICAgICAgICAgICAvLyBJZiBkZWVwIG1lcmdlIGFuZCBwcm9wZXJ0eSBpcyBhbiBvYmplY3QsIG1lcmdlIHByb3BlcnRpZXNcbiAgICAgICAgICAgICAgICAgICAgaWYgKGRlZXAgJiYgT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKG9ialtwcm9wXSkgPT09ICdbb2JqZWN0IE9iamVjdF0nKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBleHRlbmRlZFtwcm9wXSA9IGV4dGVuZCh0cnVlLCBleHRlbmRlZFtwcm9wXSwgb2JqW3Byb3BdKTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGV4dGVuZGVkW3Byb3BdID0gb2JqW3Byb3BdO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuXG4gICAgICAgIC8vIExvb3AgdGhyb3VnaCBlYWNoIG9iamVjdCBhbmQgY29uZHVjdCBhIG1lcmdlXG4gICAgICAgIGZvciAoOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHZhciBvYmogPSBhcmd1bWVudHNbaV07XG4gICAgICAgICAgICBtZXJnZShvYmopO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGV4dGVuZGVkO1xuXG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIEdldCB0aGUgaGVpZ2h0IG9mIGFuIGVsZW1lbnQuXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0gIHtOb2RlfSBlbGVtIFRoZSBlbGVtZW50IHRvIGdldCB0aGUgaGVpZ2h0IG9mXG4gICAgICogQHJldHVybiB7TnVtYmVyfSAgICBUaGUgZWxlbWVudCdzIGhlaWdodCBpbiBwaXhlbHNcbiAgICAgKi9cbiAgICB2YXIgZ2V0SGVpZ2h0ID0gZnVuY3Rpb24oZWxlbSkge1xuICAgICAgICByZXR1cm4gTWF0aC5tYXgoZWxlbS5zY3JvbGxIZWlnaHQsIGVsZW0ub2Zmc2V0SGVpZ2h0LCBlbGVtLmNsaWVudEhlaWdodCk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIEdldCB0aGUgY2xvc2VzdCBtYXRjaGluZyBlbGVtZW50IHVwIHRoZSBET00gdHJlZS5cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSAge0VsZW1lbnR9IGVsZW0gICAgIFN0YXJ0aW5nIGVsZW1lbnRcbiAgICAgKiBAcGFyYW0gIHtTdHJpbmd9ICBzZWxlY3RvciBTZWxlY3RvciB0byBtYXRjaCBhZ2FpbnN0IChjbGFzcywgSUQsIGRhdGEgYXR0cmlidXRlLCBvciB0YWcpXG4gICAgICogQHJldHVybiB7Qm9vbGVhbnxFbGVtZW50fSAgUmV0dXJucyBudWxsIGlmIG5vdCBtYXRjaCBmb3VuZFxuICAgICAqL1xuICAgIHZhciBnZXRDbG9zZXN0ID0gZnVuY3Rpb24oZWxlbSwgc2VsZWN0b3IpIHtcblxuICAgICAgICAvLyBWYXJpYWJsZXNcbiAgICAgICAgdmFyIGZpcnN0Q2hhciA9IHNlbGVjdG9yLmNoYXJBdCgwKTtcbiAgICAgICAgdmFyIHN1cHBvcnRzID0gJ2NsYXNzTGlzdCcgaW4gZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50O1xuICAgICAgICB2YXIgYXR0cmlidXRlLCB2YWx1ZTtcblxuICAgICAgICAvLyBJZiBzZWxlY3RvciBpcyBhIGRhdGEgYXR0cmlidXRlLCBzcGxpdCBhdHRyaWJ1dGUgZnJvbSB2YWx1ZVxuICAgICAgICBpZiAoZmlyc3RDaGFyID09PSAnWycpIHtcbiAgICAgICAgICAgIHNlbGVjdG9yID0gc2VsZWN0b3Iuc3Vic3RyKDEsIHNlbGVjdG9yLmxlbmd0aCAtIDIpO1xuICAgICAgICAgICAgYXR0cmlidXRlID0gc2VsZWN0b3Iuc3BsaXQoJz0nKTtcblxuICAgICAgICAgICAgaWYgKGF0dHJpYnV0ZS5sZW5ndGggPiAxKSB7XG4gICAgICAgICAgICAgICAgdmFsdWUgPSB0cnVlO1xuICAgICAgICAgICAgICAgIGF0dHJpYnV0ZVsxXSA9IGF0dHJpYnV0ZVsxXS5yZXBsYWNlKC9cIi9nLCAnJykucmVwbGFjZSgvJy9nLCAnJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyBHZXQgY2xvc2VzdCBtYXRjaFxuICAgICAgICBmb3IgKDsgZWxlbSAmJiBlbGVtICE9PSBkb2N1bWVudDsgZWxlbSA9IGVsZW0ucGFyZW50Tm9kZSkge1xuXG4gICAgICAgICAgICAvLyBJZiBzZWxlY3RvciBpcyBhIGNsYXNzXG4gICAgICAgICAgICBpZiAoZmlyc3RDaGFyID09PSAnLicpIHtcbiAgICAgICAgICAgICAgICBpZiAoc3VwcG9ydHMpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGVsZW0uY2xhc3NMaXN0LmNvbnRhaW5zKHNlbGVjdG9yLnN1YnN0cigxKSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBlbGVtO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG5ldyBSZWdFeHAoJyhefFxcXFxzKScgKyBzZWxlY3Rvci5zdWJzdHIoMSkgKyAnKFxcXFxzfCQpJykudGVzdChlbGVtLmNsYXNzTmFtZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBlbGVtO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBJZiBzZWxlY3RvciBpcyBhbiBJRFxuICAgICAgICAgICAgaWYgKGZpcnN0Q2hhciA9PT0gJyMnKSB7XG4gICAgICAgICAgICAgICAgaWYgKGVsZW0uaWQgPT09IHNlbGVjdG9yLnN1YnN0cigxKSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZWxlbTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIElmIHNlbGVjdG9yIGlzIGEgZGF0YSBhdHRyaWJ1dGVcbiAgICAgICAgICAgIGlmIChmaXJzdENoYXIgPT09ICdbJykge1xuICAgICAgICAgICAgICAgIGlmIChlbGVtLmhhc0F0dHJpYnV0ZShhdHRyaWJ1dGVbMF0pKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICh2YWx1ZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGVsZW0uZ2V0QXR0cmlidXRlKGF0dHJpYnV0ZVswXSkgPT09IGF0dHJpYnV0ZVsxXSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBlbGVtO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGVsZW07XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIElmIHNlbGVjdG9yIGlzIGEgdGFnXG4gICAgICAgICAgICBpZiAoZWxlbS50YWdOYW1lLnRvTG93ZXJDYXNlKCkgPT09IHNlbGVjdG9yKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGVsZW07XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBudWxsO1xuXG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIEVzY2FwZSBzcGVjaWFsIGNoYXJhY3RlcnMgZm9yIHVzZSB3aXRoIHF1ZXJ5U2VsZWN0b3JcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBpZCBUaGUgYW5jaG9yIElEIHRvIGVzY2FwZVxuICAgICAqIEBhdXRob3IgTWF0aGlhcyBCeW5lbnNcbiAgICAgKiBAbGluayBodHRwczovL2dpdGh1Yi5jb20vbWF0aGlhc2J5bmVucy9DU1MuZXNjYXBlXG4gICAgICovXG4gICAgdmFyIGVzY2FwZUNoYXJhY3RlcnMgPSBmdW5jdGlvbihpZCkge1xuICAgICAgICB2YXIgc3RyaW5nID0gU3RyaW5nKGlkKTtcbiAgICAgICAgdmFyIGxlbmd0aCA9IHN0cmluZy5sZW5ndGg7XG4gICAgICAgIHZhciBpbmRleCA9IC0xO1xuICAgICAgICB2YXIgY29kZVVuaXQ7XG4gICAgICAgIHZhciByZXN1bHQgPSAnJztcbiAgICAgICAgdmFyIGZpcnN0Q29kZVVuaXQgPSBzdHJpbmcuY2hhckNvZGVBdCgwKTtcbiAgICAgICAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICAgICAgICAgIGNvZGVVbml0ID0gc3RyaW5nLmNoYXJDb2RlQXQoaW5kZXgpO1xuICAgICAgICAgICAgLy8gTm90ZTogdGhlcmXigJlzIG5vIG5lZWQgdG8gc3BlY2lhbC1jYXNlIGFzdHJhbCBzeW1ib2xzLCBzdXJyb2dhdGVcbiAgICAgICAgICAgIC8vIHBhaXJzLCBvciBsb25lIHN1cnJvZ2F0ZXMuXG5cbiAgICAgICAgICAgIC8vIElmIHRoZSBjaGFyYWN0ZXIgaXMgTlVMTCAoVSswMDAwKSwgdGhlbiB0aHJvdyBhblxuICAgICAgICAgICAgLy8gYEludmFsaWRDaGFyYWN0ZXJFcnJvcmAgZXhjZXB0aW9uIGFuZCB0ZXJtaW5hdGUgdGhlc2Ugc3RlcHMuXG4gICAgICAgICAgICBpZiAoY29kZVVuaXQgPT09IDB4MDAwMCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBJbnZhbGlkQ2hhcmFjdGVyRXJyb3IoXG4gICAgICAgICAgICAgICAgICAgICdJbnZhbGlkIGNoYXJhY3RlcjogdGhlIGlucHV0IGNvbnRhaW5zIFUrMDAwMC4nXG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKFxuICAgICAgICAgICAgICAgIC8vIElmIHRoZSBjaGFyYWN0ZXIgaXMgaW4gdGhlIHJhbmdlIFtcXDEtXFwxRl0gKFUrMDAwMSB0byBVKzAwMUYpIG9yIGlzXG4gICAgICAgICAgICAgICAgLy8gVSswMDdGLCBb4oCmXVxuICAgICAgICAgICAgICAgIChjb2RlVW5pdCA+PSAweDAwMDEgJiYgY29kZVVuaXQgPD0gMHgwMDFGKSB8fCBjb2RlVW5pdCA9PSAweDAwN0YgfHxcbiAgICAgICAgICAgICAgICAvLyBJZiB0aGUgY2hhcmFjdGVyIGlzIHRoZSBmaXJzdCBjaGFyYWN0ZXIgYW5kIGlzIGluIHRoZSByYW5nZSBbMC05XVxuICAgICAgICAgICAgICAgIC8vIChVKzAwMzAgdG8gVSswMDM5KSwgW+KApl1cbiAgICAgICAgICAgICAgICAoaW5kZXggPT09IDAgJiYgY29kZVVuaXQgPj0gMHgwMDMwICYmIGNvZGVVbml0IDw9IDB4MDAzOSkgfHxcbiAgICAgICAgICAgICAgICAvLyBJZiB0aGUgY2hhcmFjdGVyIGlzIHRoZSBzZWNvbmQgY2hhcmFjdGVyIGFuZCBpcyBpbiB0aGUgcmFuZ2UgWzAtOV1cbiAgICAgICAgICAgICAgICAvLyAoVSswMDMwIHRvIFUrMDAzOSkgYW5kIHRoZSBmaXJzdCBjaGFyYWN0ZXIgaXMgYSBgLWAgKFUrMDAyRCksIFvigKZdXG4gICAgICAgICAgICAgICAgKFxuICAgICAgICAgICAgICAgICAgICBpbmRleCA9PT0gMSAmJlxuICAgICAgICAgICAgICAgICAgICBjb2RlVW5pdCA+PSAweDAwMzAgJiYgY29kZVVuaXQgPD0gMHgwMDM5ICYmXG4gICAgICAgICAgICAgICAgICAgIGZpcnN0Q29kZVVuaXQgPT09IDB4MDAyRFxuICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICAgIC8vIGh0dHA6Ly9kZXYudzMub3JnL2Nzc3dnL2Nzc29tLyNlc2NhcGUtYS1jaGFyYWN0ZXItYXMtY29kZS1wb2ludFxuICAgICAgICAgICAgICAgIHJlc3VsdCArPSAnXFxcXCcgKyBjb2RlVW5pdC50b1N0cmluZygxNikgKyAnICc7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIElmIHRoZSBjaGFyYWN0ZXIgaXMgbm90IGhhbmRsZWQgYnkgb25lIG9mIHRoZSBhYm92ZSBydWxlcyBhbmQgaXNcbiAgICAgICAgICAgIC8vIGdyZWF0ZXIgdGhhbiBvciBlcXVhbCB0byBVKzAwODAsIGlzIGAtYCAoVSswMDJEKSBvciBgX2AgKFUrMDA1RiksIG9yXG4gICAgICAgICAgICAvLyBpcyBpbiBvbmUgb2YgdGhlIHJhbmdlcyBbMC05XSAoVSswMDMwIHRvIFUrMDAzOSksIFtBLVpdIChVKzAwNDEgdG9cbiAgICAgICAgICAgIC8vIFUrMDA1QSksIG9yIFthLXpdIChVKzAwNjEgdG8gVSswMDdBKSwgW+KApl1cbiAgICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICAgICBjb2RlVW5pdCA+PSAweDAwODAgfHxcbiAgICAgICAgICAgICAgICBjb2RlVW5pdCA9PT0gMHgwMDJEIHx8XG4gICAgICAgICAgICAgICAgY29kZVVuaXQgPT09IDB4MDA1RiB8fFxuICAgICAgICAgICAgICAgIGNvZGVVbml0ID49IDB4MDAzMCAmJiBjb2RlVW5pdCA8PSAweDAwMzkgfHxcbiAgICAgICAgICAgICAgICBjb2RlVW5pdCA+PSAweDAwNDEgJiYgY29kZVVuaXQgPD0gMHgwMDVBIHx8XG4gICAgICAgICAgICAgICAgY29kZVVuaXQgPj0gMHgwMDYxICYmIGNvZGVVbml0IDw9IDB4MDA3QVxuICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgICAgLy8gdGhlIGNoYXJhY3RlciBpdHNlbGZcbiAgICAgICAgICAgICAgICByZXN1bHQgKz0gc3RyaW5nLmNoYXJBdChpbmRleCk7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIE90aGVyd2lzZSwgdGhlIGVzY2FwZWQgY2hhcmFjdGVyLlxuICAgICAgICAgICAgLy8gaHR0cDovL2Rldi53My5vcmcvY3Nzd2cvY3Nzb20vI2VzY2FwZS1hLWNoYXJhY3RlclxuICAgICAgICAgICAgcmVzdWx0ICs9ICdcXFxcJyArIHN0cmluZy5jaGFyQXQoaW5kZXgpO1xuXG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogQ2FsY3VsYXRlIHRoZSBlYXNpbmcgcGF0dGVyblxuICAgICAqIEBwcml2YXRlXG4gICAgICogQGxpbmsgaHR0cHM6Ly9naXN0LmdpdGh1Yi5jb20vZ3JlLzE2NTAyOTRcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gdHlwZSBFYXNpbmcgcGF0dGVyblxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSB0aW1lIFRpbWUgYW5pbWF0aW9uIHNob3VsZCB0YWtlIHRvIGNvbXBsZXRlXG4gICAgICogQHJldHVybnMge051bWJlcn1cbiAgICAgKi9cbiAgICB2YXIgZWFzaW5nUGF0dGVybiA9IGZ1bmN0aW9uKHR5cGUsIHRpbWUpIHtcbiAgICAgICAgdmFyIHBhdHRlcm47XG4gICAgICAgIGlmICh0eXBlID09PSAnZWFzZUluUXVhZCcpIHBhdHRlcm4gPSB0aW1lICogdGltZTsgLy8gYWNjZWxlcmF0aW5nIGZyb20gemVybyB2ZWxvY2l0eVxuICAgICAgICBpZiAodHlwZSA9PT0gJ2Vhc2VPdXRRdWFkJykgcGF0dGVybiA9IHRpbWUgKiAoMiAtIHRpbWUpOyAvLyBkZWNlbGVyYXRpbmcgdG8gemVybyB2ZWxvY2l0eVxuICAgICAgICBpZiAodHlwZSA9PT0gJ2Vhc2VJbk91dFF1YWQnKSBwYXR0ZXJuID0gdGltZSA8IDAuNSA/IDIgKiB0aW1lICogdGltZSA6IC0xICsgKDQgLSAyICogdGltZSkgKiB0aW1lOyAvLyBhY2NlbGVyYXRpb24gdW50aWwgaGFsZndheSwgdGhlbiBkZWNlbGVyYXRpb25cbiAgICAgICAgaWYgKHR5cGUgPT09ICdlYXNlSW5DdWJpYycpIHBhdHRlcm4gPSB0aW1lICogdGltZSAqIHRpbWU7IC8vIGFjY2VsZXJhdGluZyBmcm9tIHplcm8gdmVsb2NpdHlcbiAgICAgICAgaWYgKHR5cGUgPT09ICdlYXNlT3V0Q3ViaWMnKSBwYXR0ZXJuID0gKC0tdGltZSkgKiB0aW1lICogdGltZSArIDE7IC8vIGRlY2VsZXJhdGluZyB0byB6ZXJvIHZlbG9jaXR5XG4gICAgICAgIGlmICh0eXBlID09PSAnZWFzZUluT3V0Q3ViaWMnKSBwYXR0ZXJuID0gdGltZSA8IDAuNSA/IDQgKiB0aW1lICogdGltZSAqIHRpbWUgOiAodGltZSAtIDEpICogKDIgKiB0aW1lIC0gMikgKiAoMiAqIHRpbWUgLSAyKSArIDE7IC8vIGFjY2VsZXJhdGlvbiB1bnRpbCBoYWxmd2F5LCB0aGVuIGRlY2VsZXJhdGlvblxuICAgICAgICBpZiAodHlwZSA9PT0gJ2Vhc2VJblF1YXJ0JykgcGF0dGVybiA9IHRpbWUgKiB0aW1lICogdGltZSAqIHRpbWU7IC8vIGFjY2VsZXJhdGluZyBmcm9tIHplcm8gdmVsb2NpdHlcbiAgICAgICAgaWYgKHR5cGUgPT09ICdlYXNlT3V0UXVhcnQnKSBwYXR0ZXJuID0gMSAtICgtLXRpbWUpICogdGltZSAqIHRpbWUgKiB0aW1lOyAvLyBkZWNlbGVyYXRpbmcgdG8gemVybyB2ZWxvY2l0eVxuICAgICAgICBpZiAodHlwZSA9PT0gJ2Vhc2VJbk91dFF1YXJ0JykgcGF0dGVybiA9IHRpbWUgPCAwLjUgPyA4ICogdGltZSAqIHRpbWUgKiB0aW1lICogdGltZSA6IDEgLSA4ICogKC0tdGltZSkgKiB0aW1lICogdGltZSAqIHRpbWU7IC8vIGFjY2VsZXJhdGlvbiB1bnRpbCBoYWxmd2F5LCB0aGVuIGRlY2VsZXJhdGlvblxuICAgICAgICBpZiAodHlwZSA9PT0gJ2Vhc2VJblF1aW50JykgcGF0dGVybiA9IHRpbWUgKiB0aW1lICogdGltZSAqIHRpbWUgKiB0aW1lOyAvLyBhY2NlbGVyYXRpbmcgZnJvbSB6ZXJvIHZlbG9jaXR5XG4gICAgICAgIGlmICh0eXBlID09PSAnZWFzZU91dFF1aW50JykgcGF0dGVybiA9IDEgKyAoLS10aW1lKSAqIHRpbWUgKiB0aW1lICogdGltZSAqIHRpbWU7IC8vIGRlY2VsZXJhdGluZyB0byB6ZXJvIHZlbG9jaXR5XG4gICAgICAgIGlmICh0eXBlID09PSAnZWFzZUluT3V0UXVpbnQnKSBwYXR0ZXJuID0gdGltZSA8IDAuNSA/IDE2ICogdGltZSAqIHRpbWUgKiB0aW1lICogdGltZSAqIHRpbWUgOiAxICsgMTYgKiAoLS10aW1lKSAqIHRpbWUgKiB0aW1lICogdGltZSAqIHRpbWU7IC8vIGFjY2VsZXJhdGlvbiB1bnRpbCBoYWxmd2F5LCB0aGVuIGRlY2VsZXJhdGlvblxuICAgICAgICByZXR1cm4gcGF0dGVybiB8fCB0aW1lOyAvLyBubyBlYXNpbmcsIG5vIGFjY2VsZXJhdGlvblxuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBDYWxjdWxhdGUgaG93IGZhciB0byBzY3JvbGxcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7RWxlbWVudH0gYW5jaG9yIFRoZSBhbmNob3IgZWxlbWVudCB0byBzY3JvbGwgdG9cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gaGVhZGVySGVpZ2h0IEhlaWdodCBvZiBhIGZpeGVkIGhlYWRlciwgaWYgYW55XG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IG9mZnNldCBOdW1iZXIgb2YgcGl4ZWxzIGJ5IHdoaWNoIHRvIG9mZnNldCBzY3JvbGxcbiAgICAgKiBAcmV0dXJucyB7TnVtYmVyfVxuICAgICAqL1xuICAgIHZhciBnZXRFbmRMb2NhdGlvbiA9IGZ1bmN0aW9uKGFuY2hvciwgaGVhZGVySGVpZ2h0LCBvZmZzZXQpIHtcbiAgICAgICAgdmFyIGxvY2F0aW9uID0gMDtcbiAgICAgICAgaWYgKGFuY2hvci5vZmZzZXRQYXJlbnQpIHtcbiAgICAgICAgICAgIGRvIHtcbiAgICAgICAgICAgICAgICBsb2NhdGlvbiArPSBhbmNob3Iub2Zmc2V0VG9wO1xuICAgICAgICAgICAgICAgIGFuY2hvciA9IGFuY2hvci5vZmZzZXRQYXJlbnQ7XG4gICAgICAgICAgICB9IHdoaWxlIChhbmNob3IpO1xuICAgICAgICB9XG4gICAgICAgIGxvY2F0aW9uID0gbG9jYXRpb24gLSBoZWFkZXJIZWlnaHQgLSBvZmZzZXQ7XG4gICAgICAgIHJldHVybiBsb2NhdGlvbiA+PSAwID8gbG9jYXRpb24gOiAwO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBEZXRlcm1pbmUgdGhlIGRvY3VtZW50J3MgaGVpZ2h0XG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcmV0dXJucyB7TnVtYmVyfVxuICAgICAqL1xuICAgIHZhciBnZXREb2N1bWVudEhlaWdodCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gTWF0aC5tYXgoXG4gICAgICAgICAgICByb290LmRvY3VtZW50LmJvZHkuc2Nyb2xsSGVpZ2h0LCByb290LmRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5zY3JvbGxIZWlnaHQsXG4gICAgICAgICAgICByb290LmRvY3VtZW50LmJvZHkub2Zmc2V0SGVpZ2h0LCByb290LmRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5vZmZzZXRIZWlnaHQsXG4gICAgICAgICAgICByb290LmRvY3VtZW50LmJvZHkuY2xpZW50SGVpZ2h0LCByb290LmRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5jbGllbnRIZWlnaHRcbiAgICAgICAgKTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogQ29udmVydCBkYXRhLW9wdGlvbnMgYXR0cmlidXRlIGludG8gYW4gb2JqZWN0IG9mIGtleS92YWx1ZSBwYWlyc1xuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IG9wdGlvbnMgTGluay1zcGVjaWZpYyBvcHRpb25zIGFzIGEgZGF0YSBhdHRyaWJ1dGUgc3RyaW5nXG4gICAgICogQHJldHVybnMge09iamVjdH1cbiAgICAgKi9cbiAgICB2YXIgZ2V0RGF0YU9wdGlvbnMgPSBmdW5jdGlvbihvcHRpb25zKSB7XG4gICAgICAgIHJldHVybiAhb3B0aW9ucyB8fCAhKHR5cGVvZiBKU09OID09PSAnb2JqZWN0JyAmJiB0eXBlb2YgSlNPTi5wYXJzZSA9PT0gJ2Z1bmN0aW9uJykgPyB7fSA6IEpTT04ucGFyc2Uob3B0aW9ucyk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIFVwZGF0ZSB0aGUgVVJMXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0VsZW1lbnR9IGFuY2hvciBUaGUgZWxlbWVudCB0byBzY3JvbGwgdG9cbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IHVybCBXaGV0aGVyIG9yIG5vdCB0byB1cGRhdGUgdGhlIFVSTCBoaXN0b3J5XG4gICAgICovXG4gICAgdmFyIHVwZGF0ZVVybCA9IGZ1bmN0aW9uKGFuY2hvciwgdXJsKSB7XG4gICAgICAgIGlmIChyb290Lmhpc3RvcnkucHVzaFN0YXRlICYmICh1cmwgfHwgdXJsID09PSAndHJ1ZScpKSB7XG4gICAgICAgICAgICByb290Lmhpc3RvcnkucHVzaFN0YXRlKG51bGwsIG51bGwsIFtyb290LmxvY2F0aW9uLnByb3RvY29sLCAnLy8nLCByb290LmxvY2F0aW9uLmhvc3QsIHJvb3QubG9jYXRpb24ucGF0aG5hbWUsIHJvb3QubG9jYXRpb24uc2VhcmNoLCBhbmNob3JdLmpvaW4oJycpKTtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICB2YXIgZ2V0SGVhZGVySGVpZ2h0ID0gZnVuY3Rpb24oaGVhZGVyKSB7XG4gICAgICAgIHJldHVybiBoZWFkZXIgPT09IG51bGwgPyAwIDogKGdldEhlaWdodChoZWFkZXIpICsgaGVhZGVyLm9mZnNldFRvcCk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIFN0YXJ0L3N0b3AgdGhlIHNjcm9sbGluZyBhbmltYXRpb25cbiAgICAgKiBAcHVibGljXG4gICAgICogQHBhcmFtIHtFbGVtZW50fSB0b2dnbGUgVGhlIGVsZW1lbnQgdGhhdCB0b2dnbGVkIHRoZSBzY3JvbGwgZXZlbnRcbiAgICAgKiBAcGFyYW0ge0VsZW1lbnR9IGFuY2hvciBUaGUgZWxlbWVudCB0byBzY3JvbGwgdG9cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9uc1xuICAgICAqL1xuICAgIHNtb290aFNjcm9sbC5hbmltYXRlU2Nyb2xsID0gZnVuY3Rpb24odG9nZ2xlLCBhbmNob3IsIG9wdGlvbnMpIHtcblxuICAgICAgICAvLyBPcHRpb25zIGFuZCBvdmVycmlkZXNcbiAgICAgICAgdmFyIG92ZXJyaWRlcyA9IGdldERhdGFPcHRpb25zKHRvZ2dsZSA/IHRvZ2dsZS5nZXRBdHRyaWJ1dGUoJ2RhdGEtb3B0aW9ucycpIDogbnVsbCk7XG4gICAgICAgIHZhciBzZXR0aW5ncyA9IGV4dGVuZChzZXR0aW5ncyB8fCBkZWZhdWx0cywgb3B0aW9ucyB8fCB7fSwgb3ZlcnJpZGVzKTsgLy8gTWVyZ2UgdXNlciBvcHRpb25zIHdpdGggZGVmYXVsdHNcbiAgICAgICAgYW5jaG9yID0gJyMnICsgZXNjYXBlQ2hhcmFjdGVycyhhbmNob3Iuc3Vic3RyKDEpKTsgLy8gRXNjYXBlIHNwZWNpYWwgY2hhcmFjdGVycyBhbmQgbGVhZGluZyBudW1iZXJzXG5cbiAgICAgICAgLy8gU2VsZWN0b3JzIGFuZCB2YXJpYWJsZXNcbiAgICAgICAgdmFyIGFuY2hvckVsZW0gPSBhbmNob3IgPT09ICcjJyA/IHJvb3QuZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50IDogcm9vdC5kb2N1bWVudC5xdWVyeVNlbGVjdG9yKGFuY2hvcik7XG4gICAgICAgIHZhciBzdGFydExvY2F0aW9uID0gcm9vdC5wYWdlWU9mZnNldDsgLy8gQ3VycmVudCBsb2NhdGlvbiBvbiB0aGUgcGFnZVxuICAgICAgICBpZiAoIWZpeGVkSGVhZGVyKSB7XG4gICAgICAgICAgICBmaXhlZEhlYWRlciA9IHJvb3QuZG9jdW1lbnQucXVlcnlTZWxlY3RvcihzZXR0aW5ncy5zZWxlY3RvckhlYWRlcik7XG4gICAgICAgIH0gLy8gR2V0IHRoZSBmaXhlZCBoZWFkZXIgaWYgbm90IGFscmVhZHkgc2V0XG4gICAgICAgIGlmICghaGVhZGVySGVpZ2h0KSB7XG4gICAgICAgICAgICBoZWFkZXJIZWlnaHQgPSBnZXRIZWFkZXJIZWlnaHQoZml4ZWRIZWFkZXIpO1xuICAgICAgICB9IC8vIEdldCB0aGUgaGVpZ2h0IG9mIGEgZml4ZWQgaGVhZGVyIGlmIG9uZSBleGlzdHMgYW5kIG5vdCBhbHJlYWR5IHNldFxuICAgICAgICB2YXIgZW5kTG9jYXRpb24gPSBnZXRFbmRMb2NhdGlvbihhbmNob3JFbGVtLCBoZWFkZXJIZWlnaHQsIHBhcnNlSW50KHNldHRpbmdzLm9mZnNldCwgMTApKTsgLy8gU2Nyb2xsIHRvIGxvY2F0aW9uXG4gICAgICAgIHZhciBhbmltYXRpb25JbnRlcnZhbDsgLy8gaW50ZXJ2YWwgdGltZXJcbiAgICAgICAgdmFyIGRpc3RhbmNlID0gZW5kTG9jYXRpb24gLSBzdGFydExvY2F0aW9uOyAvLyBkaXN0YW5jZSB0byB0cmF2ZWxcbiAgICAgICAgdmFyIGRvY3VtZW50SGVpZ2h0ID0gZ2V0RG9jdW1lbnRIZWlnaHQoKTtcbiAgICAgICAgdmFyIHRpbWVMYXBzZWQgPSAwO1xuICAgICAgICB2YXIgcGVyY2VudGFnZSwgcG9zaXRpb247XG5cbiAgICAgICAgLy8gVXBkYXRlIFVSTFxuICAgICAgICB1cGRhdGVVcmwoYW5jaG9yLCBzZXR0aW5ncy51cGRhdGVVUkwpO1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBTdG9wIHRoZSBzY3JvbGwgYW5pbWF0aW9uIHdoZW4gaXQgcmVhY2hlcyBpdHMgdGFyZ2V0IChvciB0aGUgYm90dG9tL3RvcCBvZiBwYWdlKVxuICAgICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICAgKiBAcGFyYW0ge051bWJlcn0gcG9zaXRpb24gQ3VycmVudCBwb3NpdGlvbiBvbiB0aGUgcGFnZVxuICAgICAgICAgKiBAcGFyYW0ge051bWJlcn0gZW5kTG9jYXRpb24gU2Nyb2xsIHRvIGxvY2F0aW9uXG4gICAgICAgICAqIEBwYXJhbSB7TnVtYmVyfSBhbmltYXRpb25JbnRlcnZhbCBIb3cgbXVjaCB0byBzY3JvbGwgb24gdGhpcyBsb29wXG4gICAgICAgICAqL1xuICAgICAgICB2YXIgc3RvcEFuaW1hdGVTY3JvbGwgPSBmdW5jdGlvbihwb3NpdGlvbiwgZW5kTG9jYXRpb24sIGFuaW1hdGlvbkludGVydmFsKSB7XG4gICAgICAgICAgICB2YXIgY3VycmVudExvY2F0aW9uID0gcm9vdC5wYWdlWU9mZnNldDtcbiAgICAgICAgICAgIGlmIChwb3NpdGlvbiA9PSBlbmRMb2NhdGlvbiB8fCBjdXJyZW50TG9jYXRpb24gPT0gZW5kTG9jYXRpb24gfHwgKChyb290LmlubmVySGVpZ2h0ICsgY3VycmVudExvY2F0aW9uKSA+PSBkb2N1bWVudEhlaWdodCkpIHtcbiAgICAgICAgICAgICAgICBjbGVhckludGVydmFsKGFuaW1hdGlvbkludGVydmFsKTtcbiAgICAgICAgICAgICAgICBhbmNob3JFbGVtLmZvY3VzKCk7XG4gICAgICAgICAgICAgICAgc2V0dGluZ3MuY2FsbGJhY2sodG9nZ2xlLCBhbmNob3IpOyAvLyBSdW4gY2FsbGJhY2tzIGFmdGVyIGFuaW1hdGlvbiBjb21wbGV0ZVxuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBMb29wIHNjcm9sbGluZyBhbmltYXRpb25cbiAgICAgICAgICogQHByaXZhdGVcbiAgICAgICAgICovXG4gICAgICAgIHZhciBsb29wQW5pbWF0ZVNjcm9sbCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgdGltZUxhcHNlZCArPSAxNjtcbiAgICAgICAgICAgIHBlcmNlbnRhZ2UgPSAodGltZUxhcHNlZCAvIHBhcnNlSW50KHNldHRpbmdzLnNwZWVkLCAxMCkpO1xuICAgICAgICAgICAgcGVyY2VudGFnZSA9IChwZXJjZW50YWdlID4gMSkgPyAxIDogcGVyY2VudGFnZTtcbiAgICAgICAgICAgIHBvc2l0aW9uID0gc3RhcnRMb2NhdGlvbiArIChkaXN0YW5jZSAqIGVhc2luZ1BhdHRlcm4oc2V0dGluZ3MuZWFzaW5nLCBwZXJjZW50YWdlKSk7XG4gICAgICAgICAgICByb290LnNjcm9sbFRvKDAsIE1hdGguZmxvb3IocG9zaXRpb24pKTtcbiAgICAgICAgICAgIHN0b3BBbmltYXRlU2Nyb2xsKHBvc2l0aW9uLCBlbmRMb2NhdGlvbiwgYW5pbWF0aW9uSW50ZXJ2YWwpO1xuICAgICAgICB9O1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBTZXQgaW50ZXJ2YWwgdGltZXJcbiAgICAgICAgICogQHByaXZhdGVcbiAgICAgICAgICovXG4gICAgICAgIHZhciBzdGFydEFuaW1hdGVTY3JvbGwgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIGFuaW1hdGlvbkludGVydmFsID0gc2V0SW50ZXJ2YWwobG9vcEFuaW1hdGVTY3JvbGwsIDE2KTtcbiAgICAgICAgfTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogUmVzZXQgcG9zaXRpb24gdG8gZml4IHdlaXJkIGlPUyBidWdcbiAgICAgICAgICogQGxpbmsgaHR0cHM6Ly9naXRodWIuY29tL2NmZXJkaW5hbmRpL3Ntb290aC1zY3JvbGwvaXNzdWVzLzQ1XG4gICAgICAgICAqL1xuICAgICAgICBpZiAocm9vdC5wYWdlWU9mZnNldCA9PT0gMCkge1xuICAgICAgICAgICAgcm9vdC5zY3JvbGxUbygwLCAwKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFN0YXJ0IHNjcm9sbGluZyBhbmltYXRpb25cbiAgICAgICAgc3RhcnRBbmltYXRlU2Nyb2xsKCk7XG5cbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogSWYgc21vb3RoIHNjcm9sbCBlbGVtZW50IGNsaWNrZWQsIGFuaW1hdGUgc2Nyb2xsXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICB2YXIgZXZlbnRIYW5kbGVyID0gZnVuY3Rpb24oZXZlbnQpIHtcbiAgICAgICAgdmFyIHRvZ2dsZSA9IGdldENsb3Nlc3QoZXZlbnQudGFyZ2V0LCBzZXR0aW5ncy5zZWxlY3Rvcik7XG4gICAgICAgIGlmICh0b2dnbGUgJiYgdG9nZ2xlLnRhZ05hbWUudG9Mb3dlckNhc2UoKSA9PT0gJ2EnKSB7XG4gICAgICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpOyAvLyBQcmV2ZW50IGRlZmF1bHQgY2xpY2sgZXZlbnRcbiAgICAgICAgICAgIHNtb290aFNjcm9sbC5hbmltYXRlU2Nyb2xsKHRvZ2dsZSwgdG9nZ2xlLmhhc2gsIHNldHRpbmdzKTsgLy8gQW5pbWF0ZSBzY3JvbGxcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBPbiB3aW5kb3cgc2Nyb2xsIGFuZCByZXNpemUsIG9ubHkgcnVuIGV2ZW50cyBhdCBhIHJhdGUgb2YgMTVmcHMgZm9yIGJldHRlciBwZXJmb3JtYW5jZVxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtICB7RnVuY3Rpb259IGV2ZW50VGltZW91dCBUaW1lb3V0IGZ1bmN0aW9uXG4gICAgICogQHBhcmFtICB7T2JqZWN0fSBzZXR0aW5nc1xuICAgICAqL1xuICAgIHZhciBldmVudFRocm90dGxlciA9IGZ1bmN0aW9uKGV2ZW50KSB7XG4gICAgICAgIGlmICghZXZlbnRUaW1lb3V0KSB7XG4gICAgICAgICAgICBldmVudFRpbWVvdXQgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIGV2ZW50VGltZW91dCA9IG51bGw7IC8vIFJlc2V0IHRpbWVvdXRcbiAgICAgICAgICAgICAgICBoZWFkZXJIZWlnaHQgPSBnZXRIZWFkZXJIZWlnaHQoZml4ZWRIZWFkZXIpOyAvLyBHZXQgdGhlIGhlaWdodCBvZiBhIGZpeGVkIGhlYWRlciBpZiBvbmUgZXhpc3RzXG4gICAgICAgICAgICB9LCA2Nik7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogRGVzdHJveSB0aGUgY3VycmVudCBpbml0aWFsaXphdGlvbi5cbiAgICAgKiBAcHVibGljXG4gICAgICovXG4gICAgc21vb3RoU2Nyb2xsLmRlc3Ryb3kgPSBmdW5jdGlvbigpIHtcblxuICAgICAgICAvLyBJZiBwbHVnaW4gaXNuJ3QgYWxyZWFkeSBpbml0aWFsaXplZCwgc3RvcFxuICAgICAgICBpZiAoIXNldHRpbmdzKSByZXR1cm47XG5cbiAgICAgICAgLy8gUmVtb3ZlIGV2ZW50IGxpc3RlbmVyc1xuICAgICAgICByb290LmRvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgZXZlbnRIYW5kbGVyLCBmYWxzZSk7XG4gICAgICAgIHJvb3QucmVtb3ZlRXZlbnRMaXN0ZW5lcigncmVzaXplJywgZXZlbnRUaHJvdHRsZXIsIGZhbHNlKTtcblxuICAgICAgICAvLyBSZXNldCB2YXJhaWJsZXNcbiAgICAgICAgc2V0dGluZ3MgPSBudWxsO1xuICAgICAgICBldmVudFRpbWVvdXQgPSBudWxsO1xuICAgICAgICBmaXhlZEhlYWRlciA9IG51bGw7XG4gICAgICAgIGhlYWRlckhlaWdodCA9IG51bGw7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIEluaXRpYWxpemUgU21vb3RoIFNjcm9sbFxuICAgICAqIEBwdWJsaWNcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucyBVc2VyIHNldHRpbmdzXG4gICAgICovXG4gICAgc21vb3RoU2Nyb2xsLmluaXQgPSBmdW5jdGlvbihvcHRpb25zKSB7XG5cbiAgICAgICAgLy8gZmVhdHVyZSB0ZXN0XG4gICAgICAgIGlmICghc3VwcG9ydHMpIHJldHVybjtcblxuICAgICAgICAvLyBEZXN0cm95IGFueSBleGlzdGluZyBpbml0aWFsaXphdGlvbnNcbiAgICAgICAgc21vb3RoU2Nyb2xsLmRlc3Ryb3koKTtcblxuICAgICAgICAvLyBTZWxlY3RvcnMgYW5kIHZhcmlhYmxlc1xuICAgICAgICBzZXR0aW5ncyA9IGV4dGVuZChkZWZhdWx0cywgb3B0aW9ucyB8fCB7fSk7IC8vIE1lcmdlIHVzZXIgb3B0aW9ucyB3aXRoIGRlZmF1bHRzXG4gICAgICAgIGZpeGVkSGVhZGVyID0gcm9vdC5kb2N1bWVudC5xdWVyeVNlbGVjdG9yKHNldHRpbmdzLnNlbGVjdG9ySGVhZGVyKTsgLy8gR2V0IHRoZSBmaXhlZCBoZWFkZXJcbiAgICAgICAgaGVhZGVySGVpZ2h0ID0gZ2V0SGVhZGVySGVpZ2h0KGZpeGVkSGVhZGVyKTtcblxuICAgICAgICAvLyBXaGVuIGEgdG9nZ2xlIGlzIGNsaWNrZWQsIHJ1biB0aGUgY2xpY2sgaGFuZGxlclxuICAgICAgICByb290LmRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgZXZlbnRIYW5kbGVyLCBmYWxzZSk7XG4gICAgICAgIGlmIChmaXhlZEhlYWRlcikge1xuICAgICAgICAgICAgcm9vdC5hZGRFdmVudExpc3RlbmVyKCdyZXNpemUnLCBldmVudFRocm90dGxlciwgZmFsc2UpO1xuICAgICAgICB9XG5cbiAgICB9O1xuXG5cbiAgICAvL1xuICAgIC8vIFB1YmxpYyBBUElzXG4gICAgLy9cblxuICAgIHJldHVybiBzbW9vdGhTY3JvbGw7XG5cbn0pO1xuIl0sImZpbGUiOiJzbW9vdGgtc2Nyb2xsLm1pbi5qcyIsInNvdXJjZVJvb3QiOiIvc291cmNlLyJ9